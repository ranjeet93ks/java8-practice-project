

	// the main of lambda exp. is to enable functional programming in java:-
	
	
	// lambda exp is anonymous function without name, without return type and without modifier
	
	
	// Features of java8 :-
	// 1.Lambda Exp. 2. Functional Interface
	// 3.default & static methods os interface
	// 4.Predefined functional interface like Predicate, Function, Consumer,
	// Supplier etc.
	// 5.Double colon operator(::) method/constructor reference
	// 6.streams
	// 7.Date and Time API
	// 8.optional class
	// 9. Nasshron Javascript Engine
	
	{} is mandatory for more than 1 statement
	() is mandatory for more than 1 argument
	return is mandatory for more than 1 statement
	without {} -- we cant use return statement, compiler auto understand
	
	(n) -> { 
	n= n+1;
	return n*n;
	} // mandatory to write return to return something in {}
	
	(int n) -> {return n*n;} //valid
	(n) -> {return n*n;} //valid
	(n) -> return n*n; // valid
	(n) -> n*n; // only 1 statement ..so no need to write {} and also no need to write return statement
	 n -> n*n; //() is not mandatory for single argument
	 
	//functional interface --single abstract method(ASM)
	interface with only 1 abstract method.
	ex.- Runnable- run(), Callable - call(), Comparable -compareTo, Comparator- compare(), ActionListener- actionPerformed()
	
	use of function interface:- to invoke lambda exp.
	
	It is not mandatory to use @FunctionalInterface, 
	but it's best practice to use it with functional interfaces to avoid addition of extra methods accidentally.
	
	// functional interface is mandatory to implement lambda exp.
	
	// where there is lambda exp. we can go for anonymous class but reverse is not.
	//cuz lambda exp. is not possible for non-functional interface.
	//but anonymous class is possible for functional interface.
	
	Significance of default method :- 
	without affecting implementing class if we want to add new method to interface --> default method
	this is backward compatibility
	
	if we add any abstract method in interface, all implementing class forced to implement this
	newly added abstract method else compilation error.
	
	/// we can access default method in implementing class
	// we can override default method in implementing class --can't write default in method definition in child class
	
	//multiple inheritance is not allowed in java using extends cuz of diamond problem
	// lets say both interface has same method m1, then compiler will confuse which m1 need to call of 1st interface or of 2nd 
	
	//  we can call default method directly in child class
	// name.super.defaultmethodname
	// we could directly call abstract method in child class
	
	// static method could be accessed in child class in only 1 way :-
	interfacename.staticmethodname();
	
	// we can add main method in interface since java8 as main method is static
	
	
	//Collection Vs streams :-
	Collection -to represent a group of objects as a single entity.
	(java.util) Stream -an interface  to process objects from collections in  java.util.stream package
	Stream is related to collection while java.io stream related to files(read/write character or binary data)
	
	java.util stream for bulk operations
	
	Stream s = collection.stream();
	
	filter(Predicate) ==> Predicate => always return boolean --used for condition
	map(Function) => Function => return any value -int, ...any type --used for some operations
	ex. list.stream().filter(i->i%2==0) // for only even values from list 
	list.stream().map(i=>i+10) // add 10 to each element of list
	
	
	//descending order :--
	compare(obj1,obj2)
	//10,20 --bigger value comes before
	//if obj1<obj2 then +1 and is obj1>obj2 then -1 and if obj1=obj2 then 0 reverse for ascending order
	
	// Comparable Vs Comparator :-->>
	//compare(obj1,obj2) vs compareTo(obj)
	
	
	
	(s1,s2)
	//(s1, s2) -> s1.compareTo(s2) --natural ascending order
	//(s1, s2) -> s2.compareTo(s1) --reverse of natural order
	//(s1, s2) -> -s1.compareTo(s2) --reverse of natural order
	
	
	// method reference -- alternative to lambda exp.
		// here we didnt implemented abstract method (methodA) but instead we refer it
		// to another existing method (methodB)
		// so code reusebility
		// for method reference- mandatory to have same argument types only
		// here methodA & methodB have same argument types i.e no arg
	
	Advantage of method reference :- 	
	alternative of lambda exp
	instead of providing implementation for abstract method of functional interface, refer an already existing method to it.
	hence code reusebility
	
	ex.
	Runnable r =  object :: any non-arg method// implementation of run method refer to non-arg method of any class
	
	
	//constructor reference :: 
	// for constructor reference- mandatory to have same argument types only
	
	